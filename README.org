#+TITLE:    language.c README
#+AUTHOR:   Jan Moringen
#+EMAIL:    jmoringe@techfak.uni-bielefeld.de
#+LANGUAGE: en

#+OPTIONS:  toc:nil num:nil
#+SEQ_TODO: TODO STARTED | DONE

* STARTED Introduction

  This library provides parsers for the C programming language and its
  preprocessor as described in [[https://web.archive.org/web/20181230041359if_/http://www.open-std.org/jtc1/sc22/wg14/www/abq/c17_updated_proposed_fdis.pdf][Annex A of SO/IEC 9899:2017]]. For the
  preprocessor language, it also provides an interpreter.

  This library uses package-local nicknames. It has been tested in
  SBCL.

* STARTED Tutorial

  This section discusses different modules provided by the library:

  + [[*The Interface Package]] :: This module provides a high-level
       interface consisting of convenience functions for parsing and
       evaluating CPP or C inputs or doing multiple of those things at
       once.

  + [[*The Preprocessor Language]] :: This module provides a parser, a
       meta-model and an evaluator for the C preprocessor language.

  + [[*The C Language]] :: This module provides a parser and a meta-model.

** STARTED The Interface Package

   This module contains convenience functions for preprocessing and
   parsing C code. The corresponding ASDF system and package are both
   called ~langauge.c.interface~.

   #+BEGIN_SRC lisp :exports results :results silent
     (ql:quickload '#:language.c.interface)
   #+END_SRC

** STARTED The Preprocessor Language

*** STARTED Parsing

    The ability to parse the C preprocessor language is provided by
    the ~language.c.preprocessor.parser~ systems.

    #+BEGIN_SRC lisp :exports results :results silent
      (ql:quickload '#:language.c.preprocessor.parser)
    #+END_SRC

    After loading that system, a inputs such as strings and files can
    be parsed using the ~parse~ generic function:

    #+BEGIN_SRC lisp :exports both :results value verbatim
      (language.c.preprocessor.parser:parse "#define foo 1 + 2" 'list)
    #+END_SRC

    #+RESULTS:
    #+begin_example
    (:GROUP
     (:PART
      (((:DEFINE NIL :NAME (:IDENTIFIER NIL :NAME "foo" :BOUNDS (8 . 11))
         :REPLACEMENT
         ((:NUMBER NIL :VALUE "1" :BOUNDS (12 . 13))
          (:PUNCTUATOR NIL :WHICH :+ :BOUNDS (14 . 16))
          (:NUMBER NIL :VALUE "2" :BOUNDS (16 . 17)))
         :BOUNDS (1 . 17)))))
     :BOUNDS (0 . 17))
    NIL
    T
    #+end_example

    The second argument is a "builder" which controls the construction
    of the parse result (The "builder" concept, related protocols and
    their implementation can be found in the
    [[https://github.com/scymtym/architecture.builder-protocol][architecture.builder-protocol]] system). In the example above, the
    ~list~ builder has been used to produce a simple list-based
    representation of the parse tree.

    Another possibility is producing a parse tree consisting of
    instances of classes defined in the ~language.c.preprocessor.model~
    package:

    #+BEGIN_SRC lisp :exports both :results value verbatim
      (language.c.preprocessor.parser:parse
       "#define foo 1 + 2"
       (make-instance 'language.c.preprocessor.model:builder))
    #+END_SRC

    #+RESULTS:
    : #<LANGUAGE.C.PREPROCESSOR.MODEL:GROUP {10023739B3}>
    : NIL
    : T

*** STARTED Evaluating Syntax Trees

    #+BEGIN_SRC lisp
      (let ((ast (language.c.preprocessor.parser:parse
                  (format nil "#ifdef foo~@
                               #define foo 1~@
                               foo bar~@
                               baz fez~@
                               #endif~@
                               ")
                  (make-instance 'language.c.preprocessor.model:builder)))
            ((environment (make-instance 'language.c.preprocessor.evaluator::environment))))
        (let ()
          (language.c.preprocessor.evaluator:evaluate ast e *standard-output*)
          e))
    #+END_SRC

** STARTED The C language

*** STARTED Parsing

    #+BEGIN_SRC lisp :exports both :results value verbatim
      (language.c.c.parser:parse "int f() { return 1; }" 'list)
    #+END_SRC

    #+RESULTS:
    #+begin_example
    (:TRANSLATION-UNIT
     (:DECLARATION
      (((:FUNCTION-DEFINITION
         (:BODY
          (((:RETURN-STATEMENT
             (:VALUE
              ((((:CONSTANT NIL :TYPE :INTEGER :VALUE 1 :SIZE NIL :UNSIGNED? NIL
                  :BOUNDS (17 . 18))))))
             :BOUNDS (10 . 18))))
          :RETURN ((:INT)) :NAME (((:IDENTIFIER NIL :NAME "f" :BOUNDS (4 . 5)))))
         :BOUNDS (0 . 21)))))
     :BOUNDS (0 . 21))
    NIL
    T
    #+end_example

*** TODO Evaluating

* TODO Dictionary
