#+TITLE:    language.c README
#+AUTHOR:   Jan Moringen
#+EMAIL:    jmoringe@techfak.uni-bielefeld.de
#+LANGUAGE: en

#+OPTIONS:  toc:nil num:nil
#+SEQ_TODO: TODO STARTED | DONE

* STARTED Introduction

  This library provides parsers for the C programming language and its
  preprocessor as described in [[https://web.archive.org/web/20181230041359if_/http://www.open-std.org/jtc1/sc22/wg14/www/abq/c17_updated_proposed_fdis.pdf][Annex A of SO/IEC 9899:2017]]. For the
  preprocessor language, it also provides an interpreter.

  This library uses package-local nicknames. It has been tested in
  SBCL.

* STARTED Tutorial

  This section discusses different modules provided by the library:

  + [[*The Interface Package]] :: This module provides a high-level
       interface consisting of convenience functions for parsing and
       evaluating CPP or C inputs or doing multiple of those things at
       once.

  + [[*The Preprocessor Language]] :: This module provides a parser, a
       meta-model and an evaluator for the C preprocessor language.

  + [[*The C Language]] :: This module provides a parser and a meta-model.

** STARTED The Interface Package

   This module contains convenience functions for preprocessing and
   parsing C code. The corresponding ASDF system and package are both
   called ~language.c.interface~.

   #+BEGIN_SRC lisp :exports results :results silent
     (ql:quickload '#:language.c.interface)
   #+END_SRC

   The ~preprocess~ function of this module offers a convenient way of
   preprocessing C code:

   #+BEGIN_SRC lisp :exports both :results output
     (language.c.interface:preprocess "#define foo(x) (x<<1)
     #if foo(1) < 3
     foo(1) foo(2)
     #else
     foo(3) foo(4)
     #endif

     #define bar 1 bar 2
     bar

     #define baz(x) 1 x baz(2) baz 3
     baz(4) baz(5)")
   #+END_SRC

   #+RESULTS:
   : (1<<1)(2<<1)
   :
   : 1 bar 2
   :
   : 1 4 baz(2)baz 3 1 5 baz(2)baz 3

   The other main function is ~parse~:

   #+BEGIN_SRC lisp :exports both :results value
     (language.c.interface:parse "#define foo main() {
     int foo
       return 1;
     }")
   #+END_SRC

   #+RESULTS:
   #+begin_example
     (:TRANSLATION-UNIT
      (:DECLARATION
       (((:FUNCTION-DEFINITION
          (:BODY
           (((:RETURN-STATEMENT
              (:VALUE
               (((:CONSTANT NIL :TYPE :INTEGER :VALUE 1 :SIZE NIL :UNSIGNED? NIL
                  :BOUNDS (19 . 20)))))
              :BOUNDS (12 . 20))))
           :RETURN ((:INT)) :DECLARATOR
           (((:DIRECT-DECLARATOR
              (:NAME (((:IDENTIFIER NIL :NAME MAIN :BOUNDS (4 . 8))))) :BOUNDS
              (4 . 10)))))
          :BOUNDS (0 . 24)))))
      :BOUNDS (0 . 24))
   #+end_example

** STARTED The Preprocessor Language

*** STARTED Parsing

    The ability to parse the C preprocessor language is provided by
    the ~language.c.preprocessor.parser~ systems.

    #+BEGIN_SRC lisp :exports results :results silent
      (ql:quickload '#:language.c.preprocessor.parser)
    #+END_SRC

    After loading that system, a inputs such as strings and files can
    be parsed using the ~parse~ generic function:

    #+BEGIN_SRC lisp :exports both :results value verbatim
      (language.c.preprocessor.parser:parse "#define foo 1 + 2" 'list)
    #+END_SRC

    #+RESULTS:
    #+begin_example
    (:GROUP
     (:PART
      (((:DEFINE-OBJECT-LIKE-MACRO
         (:REPLACEMENT
          (((:NUMBER NIL :VALUE "1" :BOUNDS (12 . 13)))
           ((:PUNCTUATOR NIL :WHICH :+ :BOUNDS (14 . 16)))
           ((:NUMBER NIL :VALUE "2" :BOUNDS (16 . 17))))
          :NAME (((:IDENTIFIER NIL :NAME "foo" :BOUNDS (8 . 11)))))
         :BOUNDS (1 . 17)))))
     :BOUNDS (0 . 17))
    NIL
    T
    #+end_example

    The second argument is a "builder" which controls the construction
    of the parse result (The "builder" concept, related protocols and
    their implementation can be found in the
    [[https://github.com/scymtym/architecture.builder-protocol][architecture.builder-protocol]] system). In the example above, the
    ~list~ builder has been used to produce a simple list-based
    representation of the parse tree.

    Another possibility is producing a parse tree consisting of
    instances of classes defined in the ~language.c.preprocessor.model~
    package:

    #+BEGIN_SRC lisp :exports both :results value verbatim
      (language.c.preprocessor.parser:parse
       "#define foo 1 + 2"
       (make-instance 'language.c.preprocessor.model:builder))
    #+END_SRC

    #+RESULTS:
    : #<LANGUAGE.C.PREPROCESSOR.MODEL:GROUP {10023739B3}>
    : NIL
    : T

*** STARTED Evaluating Syntax Trees

    #+BEGIN_SRC lisp :exports both :results output verbatim
      (let* ((ast (language.c.preprocessor.parser:parse
                   (format nil "#if !defined foo~@
                                #define foo 1~@
                                foo bar~@
                                baz fez~@
                                #endif~@
                                ")
                   (make-instance 'language.c.preprocessor.model:builder)))
             (environment (make-instance 'language.c.preprocessor.evaluator::environment))
             (result (language.c.preprocessor.evaluator:evaluate
                      ast '() environment)))
        (language.c.preprocessor.evaluator::output result *standard-output*)
        (describe environment))
    #+END_SRC

    #+RESULTS:
    : 1 bar
    : baz fez
    : #<LANGUAGE.C.PREPROCESSOR.EVALUATOR:ENVIRONMENT {101827EEE3}>
    :   [standard-object]
    :
    : Slots with :INSTANCE allocation:
    :   %ENTRIES                       = #{"foo" :..

** STARTED The C Language

*** STARTED Parsing

    #+BEGIN_SRC lisp :exports both :results value verbatim
      (language.c.c.parser:parse "int f() { return 1; }" 'list)
    #+END_SRC

    #+RESULTS:
    #+begin_example
    (:TRANSLATION-UNIT
     (:DECLARATION
      (((:FUNCTION-DEFINITION
         (:BODY
          (((:RETURN-STATEMENT
             (:VALUE
              ((((:CONSTANT NIL :TYPE :INTEGER :VALUE 1 :SIZE NIL :UNSIGNED? NIL
                  :BOUNDS (17 . 18))))))
             :BOUNDS (10 . 18))))
          :RETURN ((:INT)) :NAME (((:IDENTIFIER NIL :NAME "f" :BOUNDS (4 . 5)))))
         :BOUNDS (0 . 21)))))
     :BOUNDS (0 . 21))
    NIL
    T
    #+end_example

*** TODO Evaluating

* TODO Dictionary
